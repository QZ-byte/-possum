All project .py files dump
Generated: 2025-10-20T15:15:45.611522
Project root: c:\Users\Q#\Desktop\Raccon Build 448


--- FILE: main.py ---
from ui.main_ui import RacconApp

if __name__ == "__main__":
    app = RacconApp(db_path="raccon.db")
    app.run()


--- FILE: services\db.py ---
import sqlite3
from typing import Tuple, Iterable, Optional


class Database:
    def __init__(self, path: str):
        self.path = path
        self.conn = sqlite3.connect(self.path, check_same_thread=False)
        self.conn.row_factory = sqlite3.Row
        self._init_schema()

    def _init_schema(self):
        cur = self.conn.cursor()
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS notes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                content TEXT NOT NULL DEFAULT '',
                tags TEXT NOT NULL DEFAULT '',
                created_at TEXT NOT NULL DEFAULT (datetime('now'))
            )
            """
        )
        self.conn.commit()
        cur.close()

    def execute(self, sql: str, params: Tuple = ()) -> None:
        cur = self.conn.cursor()
        cur.execute(sql, params)
        self.conn.commit()
        cur.close()

    def fetchall(self, sql: str, params: Tuple = ()) -> Iterable[sqlite3.Row]:
        cur = self.conn.cursor()
        cur.execute(sql, params)
        rows = cur.fetchall()
        cur.close()
        return rows

    def fetchone(self, sql: str, params: Tuple = ()) -> Optional[sqlite3.Row]:
        cur = self.conn.cursor()
        cur.execute(sql, params)
        row = cur.fetchone()
        cur.close()
        return row

    def close(self):
        self.conn.close()


--- FILE: services\notes_service.py ---
from typing import List, Tuple, Optional
from services.db import Database


class NotesService:
    def __init__(self, db: Database):
        self.db = db

    # Create
    def create_note(self, title: str, content: str, tags: str) -> None:
        self.db.execute(
            "INSERT INTO notes(title, content, tags) VALUES (?, ?, ?)",
            (title, content, tags)
        )

    # Read
    def get_all_notes(self) -> List[Tuple]:
        rows = self.db.fetchall(
            "SELECT id, title, tags, created_at FROM notes ORDER BY id DESC"
        )
        return [tuple(r) for r in rows]

    def get_note_by_id(self, note_id: int) -> Optional[Tuple]:
        row = self.db.fetchone(
            "SELECT id, title, content, tags, created_at FROM notes WHERE id = ?",
            (note_id,)
        )
        return tuple(row) if row else None

    def search_notes(self, query: str) -> List[Tuple]:
        q = f"%{query}%"
        rows = self.db.fetchall(
            "SELECT id, title, tags, created_at FROM notes WHERE title LIKE ? OR tags LIKE ? ORDER BY id DESC",
            (q, q)
        )
        return [tuple(r) for r in rows]

    # Update
    def update_note(self, note_id: int, title: str, content: str, tags: str) -> None:
        self.db.execute(
            "UPDATE notes SET title = ?, content = ?, tags = ? WHERE id = ?",
            (title, content, tags, note_id)
        )

    # Delete
    def delete_note(self, note_id: int) -> None:
        self.db.execute("DELETE FROM notes WHERE id = ?", (note_id,))


--- FILE: ui\debug_ui.py ---
# ui/debug_ui.py
import tkinter as tk
from tkinter import ttk
import sys, logging, queue, time, os, datetime, io

class _StreamProxy:
    def __init__(self, q, name):
        self.q = q
        self.name = name
    def write(self, data):
        if data:
            self.q.put((self.name, str(data)))
    def flush(self):
        pass

class _QueueLoggingHandler(logging.Handler):
    def __init__(self, q):
        super().__init__()
        self.q = q
    def emit(self, record):
        try:
            msg = self.format(record)
            self.q.put(("log", msg))
        except Exception:
            pass

class DebugUI:
    def __init__(self, master, autostart=False):
        self.win = tk.Toplevel(master)
        self.win.title("Debugger")
        self.win.geometry("880x520")

        self.output = tk.Text(self.win, wrap="word", state="disabled", bg="black", fg="lime")
        self.output.pack(fill="both", expand=True, padx=6, pady=6)

        ctrl = ttk.Frame(self.win); ctrl.pack(fill="x", padx=6, pady=(0,6))
        self.start_btn = ttk.Button(ctrl, text="‚ñ∂ –°—Ç–∞—Ä—Ç", command=self.start); self.start_btn.pack(side="left", padx=4)
        self.stop_btn = ttk.Button(ctrl, text="‚èπ –°—Ç–æ–ø", command=self.stop); self.stop_btn.pack(side="left", padx=4)
        self.save_btn  = ttk.Button(ctrl, text="üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å", command=self.save); self.save_btn.pack(side="left", padx=4)
        self.mode_var = tk.StringVar(value="all")
        ttk.Radiobutton(ctrl, text="All", variable=self.mode_var, value="all").pack(side="left", padx=6)
        ttk.Radiobutton(ctrl, text="Errors only", variable=self.mode_var, value="errors").pack(side="left")

        # –æ—á–µ—Ä–µ–¥—å –∏ –±—É—Ñ–µ—Ä
        self.q = queue.Queue()
        self.buffer = io.StringIO()

        # —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—ã
        self._orig_stdout = sys.stdout
        self._orig_stderr = sys.stderr
        self._orig_handlers = logging.getLogger().handlers[:]

        # logging handler
        self._log_handler = _QueueLoggingHandler(self.q)
        self._log_handler.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(message)s", "%H:%M:%S"))

        # —Ñ–ª–∞–≥ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        self.active = False

        # –∑–∞–ø—É—Å–∫ –ø–æ–ª–ª–∏–Ω–≥–∞
        self._poll()

        if autostart:
            self.start()

    def _append(self, line: str):
        self.output.configure(state="normal")
        self.output.insert("end", line + "\n")
        self.output.see("end")
        self.output.configure(state="disabled")

    def _poll(self):
        try:
            while True:
                src, data = self.q.get_nowait()
                for ln in str(data).splitlines():
                    if not ln:
                        continue
                    ts = time.strftime("[%H:%M:%S]")
                    if self.mode_var.get() == "errors":
                        if src == "log":
                            if "WARNING" in ln or "ERROR" in ln or "CRITICAL" in ln:
                                pass
                            else:
                                continue
                        elif src == "stderr":
                            pass
                        else:
                            continue
                    out = f"{ts} [{src}] {ln}"
                    self.buffer.write(out + "\n")
                    self._append(out)
        except queue.Empty:
            pass
        self.win.after(120, self._poll)

    def start(self):
        if self.active:
            self._append("[DEBUG] already started")
            return
        sys.stdout = _StreamProxy(self.q, "stdout")
        sys.stderr = _StreamProxy(self.q, "stderr")
        root_logger = logging.getLogger()
        root_logger.handlers = [self._log_handler]
        root_logger.setLevel(logging.DEBUG)
        self.active = True
        self._append("[DEBUG] started")

    def stop(self):
        if not self.active:
            self._append("[DEBUG] not active")
            return
        sys.stdout = self._orig_stdout
        sys.stderr = self._orig_stderr
        logging.getLogger().handlers = self._orig_handlers
        self.active = False
        self._append("[DEBUG] stopped")

    def save(self, path: str = None):
        if path is None:
            ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            path = os.path.join(os.path.dirname(os.path.dirname(__file__)), f"debug_log_{ts}.txt")
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(self.buffer.getvalue())
            self._append(f"[DEBUG] saved to {path}")
        except Exception as e:
            self._append(f"[DEBUG] save error: {e}")

    # —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å write/flush
    def write(self, data):
        if data:
            self.q.put(("custom", str(data)))
    def flush(self):
        pass


--- FILE: ui\dev_cli.py ---
# ui/dev_cli.py
"""
DevCLI - –Ω–µ–±–æ–ª—å—à–∞—è –≤—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è –∫–æ–Ω—Å–æ–ª—å –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞.

–ö–æ–º–∞–Ω–¥—ã:
  help                       - –ø–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥
  tables                     - –ø–æ–∫–∞–∑–∞—Ç—å —Ç–∞–±–ª–∏—Ü—ã –≤ sqlite
  notes                      - –≤—ã–≤–µ—Å—Ç–∏ –≤—Å–µ –∑–∞–º–µ—Ç–∫–∏
  sql <–∑–∞–ø—Ä–æ—Å>               - –≤—ã–ø–æ–ª–Ω–∏—Ç—å SQL –∑–∞–ø—Ä–æ—Å –∏ –ø–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
  dump                       - –≤—ã–≤–µ—Å—Ç–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ .py —Ñ–∞–π–ª–æ–≤ –≤ –æ–∫–Ω–æ
  dump save                  - —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∂–¥—ã–π .py –≤ dcli_dumps/<name>.txt
  dump all [–∏–º—è_—Ñ–∞–π–ª–∞]       - —Å–æ–±—Ä–∞—Ç—å –≤—Å–µ .py –≤ –æ–¥–∏–Ω —Ñ–∞–π–ª dcli_dumps/all_code_<ts>.txt
  debug                      - –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ Debugger (–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π)
  clear                      - –æ—á–∏—Å—Ç–∏—Ç—å –æ–∫–Ω–æ –≤—ã–≤–æ–¥–∞
"""
import os
import sys
import sqlite3
import datetime
import tkinter as tk
from tkinter import ttk

# –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π helper –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ë–î (–æ–∂–∏–¥–∞–µ—Ç—Å—è, —á—Ç–æ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –æ–±—ä–µ–∫—Ç —Å –º–µ—Ç–æ–¥–æ–º fetchall)
class _SafeDB:
    def __init__(self, db_obj):
        self._db = db_obj

    def fetchall(self, query: str):
        # –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –¥–≤–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞: –æ–±—ä–µ–∫—Ç Database —Å –º–µ—Ç–æ–¥–æ–º fetchall –∏–ª–∏ sqlite3.Connection
        if self._db is None:
            raise RuntimeError("DB not provided")
        if hasattr(self._db, "fetchall"):
            return self._db.fetchall(query)
        # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω sqlite3.Connection
        cur = self._db.cursor()
        cur.execute(query)
        return cur.fetchall()


class DevCLI:
    def __init__(self, master, db=None, notes_service=None):
        """
        master      - parent TK widget (–æ–±—ã—á–Ω–æ root –∏–ª–∏ frame)
        db          - –æ–±—ä–µ–∫—Ç –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ª–∏–±–æ sqlite3.Connection; –¥–æ–ª–∂–µ–Ω –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å fetchall(query)
        notes_service - —Å–µ—Ä–≤–∏—Å –∑–∞–º–µ—Ç–æ–∫ —Å –º–µ—Ç–æ–¥–æ–º get_all_notes()
        """
        self.master = master
        self.db = _SafeDB(db) if db is not None else None
        self.notes_service = notes_service

        self.win = tk.Toplevel(master)
        self.win.title("DCLI")
        self.win.geometry("900x520")

        # –¢–µ–∫—Å—Ç–æ–≤—ã–π –≤—ã–≤–æ–¥ (–∫–æ–Ω—Å–æ–ª—å)
        self.output = tk.Text(self.win, wrap="word", state="disabled",
                              bg="black", fg="lime", insertbackground="lime", padx=6, pady=6)
        self.output.pack(fill="both", expand=True, padx=6, pady=(6, 0))

        # –ü–∞–Ω–µ–ª—å –≤–≤–æ–¥–∞
        entry_frame = ttk.Frame(self.win)
        entry_frame.pack(fill="x", padx=6, pady=6)

        self.cmd_entry = ttk.Entry(entry_frame)
        self.cmd_entry.pack(side="left", fill="x", expand=True)
        self.cmd_entry.bind("<Return>", self._on_enter)

        ttk.Button(entry_frame, text="–í—ã–ø–æ–ª–Ω–∏—Ç—å", command=self._run_cmd).pack(side="left", padx=6)
        ttk.Button(entry_frame, text="–û—á–∏—Å—Ç–∏—Ç—å", command=self._clear).pack(side="left")

        # –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        self._print("–ì–û–¢–û–í. –í–≤–µ–¥–∏—Ç–µ 'help' –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥.")

    # ----------------- –±–∞–∑–æ–≤—ã–µ —É—Ç–∏–ª–∏—Ç—ã -----------------
    def _print(self, text: str):
        self.output.configure(state="normal")
        self.output.insert("end", text + "\n")
        self.output.see("end")
        self.output.configure(state="disabled")

    def _clear(self):
        self.output.configure(state="normal")
        self.output.delete("1.0", "end")
        self.output.configure(state="disabled")

    def _on_enter(self, _event=None):
        self._run_cmd()

    def _run_cmd(self):
        cmd = self.cmd_entry.get().strip()
        self.cmd_entry.delete(0, "end")
        self.execute(cmd)

    # ----------------- –æ—Å–Ω–æ–≤–Ω–æ–π –ø–∞—Ä—Å–µ—Ä –∫–æ–º–∞–Ω–¥ -----------------
    def execute(self, cmd: str):
        if not cmd:
            return
        self._print(f"> {cmd}")

        parts = cmd.split()
        head = parts[0].lower()

        try:
            if head == "help":
                self._cmd_help()
            elif head == "tables":
                self._cmd_tables()
            elif head == "notes":
                self._cmd_notes()
            elif head == "sql":
                self._cmd_sql(" ".join(parts[1:]))
            elif head == "dump":
                # –ü–æ–¥–∫–æ–º–∞–Ω–¥—ã: dump, dump save, dump all
                if len(parts) == 1:
                    self._dump_code(print_only=True)
                elif parts[1] == "save":
                    self._dump_code(print_only=False)
                elif parts[1] == "all":
                    name = parts[2] if len(parts) > 2 else None
                    path = self._dump_code_all(out_filename=name)
                    self._print(f"[dump all] –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤: {path}")
                else:
                    self._print("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: dump | dump save | dump all [–∏–º—è_—Ñ–∞–π–ª–∞]")
            elif head == "debug":
                self._cmd_debug()
            elif head == "clear":
                self._clear()
            else:
                self._print("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. help ‚Äî —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥.")
        except Exception as e:
            self._print(f"[ERROR] {e}")

    # ----------------- —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ–º–∞–Ω–¥ -----------------
    def _cmd_help(self):
        lines = [
            "–ö–æ–º–∞–Ω–¥—ã:",
            "  help                       - –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ—Ç —Å–ø–∏—Å–æ–∫",
            "  tables                     - –ø–æ–∫–∞–∑–∞—Ç—å —Ç–∞–±–ª–∏—Ü—ã sqlite",
            "  notes                      - –≤—ã–≤–µ—Å—Ç–∏ –≤—Å–µ –∑–∞–º–µ—Ç–∫–∏",
            "  sql <–∑–∞–ø—Ä–æ—Å>               - –≤—ã–ø–æ–ª–Ω–∏—Ç—å SQL –∑–∞–ø—Ä–æ—Å",
            "  dump                       - –≤—ã–≤–µ—Å—Ç–∏ .py –≤ –æ–∫–Ω–æ",
            "  dump save                  - —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∂–¥—ã–π .py –≤ dcli_dumps/",
            "  dump all [–∏–º—è_—Ñ–∞–π–ª–∞]       - —Å–æ–±—Ä–∞—Ç—å –≤—Å–µ .py –≤ –æ–¥–∏–Ω —Ñ–∞–π–ª",
            "  debug                      - –æ—Ç–∫—Ä—ã—Ç—å Debugger –æ–∫–Ω–æ",
            "  clear                      - –æ—á–∏—Å—Ç–∏—Ç—å –æ–∫–Ω–æ –≤—ã–≤–æ–¥–∞"
        ]
        for l in lines:
            self._print(l)

    def _cmd_tables(self):
        if self.db is None:
            self._print("[tables] DB –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∞")
            return
        try:
            rows = self.db.fetchall("SELECT name FROM sqlite_master WHERE type='table'")
            names = ", ".join(r[0] for r in rows) if rows else "(–Ω–µ—Ç —Ç–∞–±–ª–∏—Ü)"
            self._print("–¢–∞–±–ª–∏—Ü—ã: " + names)
        except Exception as e:
            self._print(f"[tables] –û—à–∏–±–∫–∞: {e}")

    def _cmd_notes(self):
        if self.notes_service is None:
            self._print("[notes] notes_service –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω")
            return
        try:
            notes = self.notes_service.get_all_notes()
            if not notes:
                self._print("(–Ω–µ—Ç –∑–∞–º–µ—Ç–æ–∫)")
                return
            for n in notes:
                self._print(str(n))
        except Exception as e:
            self._print(f"[notes] –û—à–∏–±–∫–∞: {e}")

    def _cmd_sql(self, query: str):
        if not query:
            self._print("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: sql <–∑–∞–ø—Ä–æ—Å>")
            return
        if self.db is None:
            self._print("[sql] DB –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∞")
            return
        try:
            rows = self.db.fetchall(query)
            if not rows:
                self._print("(–ø—É—Å—Ç–æ)")
                return
            for r in rows:
                self._print(str(tuple(r)))
        except sqlite3.Error as e:
            self._print(f"[SQL Error] {e}")
        except Exception as e:
            self._print(f"[sql] –û—à–∏–±–∫–∞: {e}")

    def _cmd_debug(self):
        # –û—Ç–∫—Ä—ã–≤–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω–æ–µ –æ–∫–Ω–æ DebugUI; –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –∏–º–ø–æ—Ä—Ç –≤–Ω—É—Ç—Ä–∏ –ø–∞–∫–µ—Ç–∞ ui
        try:
            from .debug_ui import DebugUI
        except Exception:
            # fallback: –ø–æ–ø—Ä–æ–±—É–µ–º –∏–º–ø–æ—Ä—Ç –∫–∞–∫ –∫–æ—Ä–Ω–µ–≤–æ–π –º–æ–¥—É–ª—å (–µ—Å–ª–∏ dev_cli.py –Ω–µ –≤ ui/)
            try:
                import importlib, os
                sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
                DebugUI = importlib.import_module("ui.debug_ui").DebugUI
            except Exception as e:
                self._print(f"[debug] –ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å DebugUI: {e}")
                return

        # –£–¥–µ—Ä–∂–∏–≤–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –æ–∫–Ω–æ, —á—Ç–æ–±—ã –æ–Ω–æ –Ω–µ –±—ã–ª–æ —Å–æ–±—Ä–∞–Ω–Ω—ã–º GC
        if not hasattr(self, "_debug_window") or self._debug_window is None or not self._debug_window.win.winfo_exists():
            try:
                self._debug_window = DebugUI(self.win if hasattr(self, "win") else self.master)
                self._print("[debug] –û–∫–Ω–æ Debugger –æ—Ç–∫—Ä—ã—Ç–æ")
            except Exception as e:
                self._print(f"[debug] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ–∫–Ω–∞: {e}")
        else:
            try:
                self._debug_window.win.lift()
                self._print("[debug] –û–∫–Ω–æ Debugger –ø–æ–¥–Ω—è—Ç–æ –Ω–∞ –ø–µ—Ä–µ–¥–Ω–∏–π –ø–ª–∞–Ω")
            except Exception:
                pass

    # ----------------- –¥–∞–º–ø –∫–æ–¥–∞ –ø–æ —Ñ–∞–π–ª–∞–º -----------------
    def _dump_code(self, print_only: bool = True):
        """
        –û–±—Ö–æ–¥–∏—Ç –ø—Ä–æ–µ–∫—Ç –æ—Ç –∫–æ—Ä–Ω—è (—Ä–æ–¥–∏—Ç–µ–ª—å –ø–∞–ø–∫–∏ ui/) –∏:
          - print_only=True: –ø–µ—á–∞—Ç–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ .py —Ñ–∞–π–ª–æ–≤ –≤ –æ–∫–Ω–æ.
          - print_only=False: —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–∞–∂–¥—ã–π .py –≤ dcli_dumps/<–∏–º—è>.txt
        """
        try:
            root_dir = os.path.dirname(os.path.dirname(__file__))
            dump_dir = os.path.join(root_dir, "dcli_dumps")
            if not print_only:
                os.makedirs(dump_dir, exist_ok=True)

            for dirpath, _, files in os.walk(root_dir):
                # –ø—Ä–æ–ø—É—Å–∫–∞–µ–º __pycache__ –∏ —Å–∫—Ä—ã—Ç—ã–µ –∫–∞—Ç–∞–ª–æ–≥–∏
                if os.path.basename(dirpath).startswith("__pycache__"):
                    continue
                for fname in sorted(files):
                    if not fname.endswith(".py"):
                        continue
                    path = os.path.join(dirpath, fname)
                    rel = os.path.relpath(path, root_dir)
                    try:
                        with open(path, "r", encoding="utf-8") as fh:
                            content = fh.read()
                    except Exception as e:
                        self._print(f"[dump] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è {rel}: {e}")
                        continue

                    if print_only:
                        self._print(f"\n--- {rel} ---")
                        # –ø–µ—á–∞—Ç–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–æ—Å—Ç—Ä–æ—á–Ω–æ, —á—Ç–æ–±—ã –Ω–µ —Ä–∞–∑–¥—É–≤–∞—Ç—å –ø–∞–º—è—Ç—å
                        for line in content.splitlines():
                            self._print(line)
                    else:
                        out_path = os.path.join(dump_dir, fname.replace(".py", ".txt"))
                        try:
                            with open(out_path, "w", encoding="utf-8") as out:
                                out.write(content)
                            self._print(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {out_path}")
                        except Exception as e:
                            self._print(f"[dump save] –û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ {out_path}: {e}")

            self._print("[dump] –ì–æ—Ç–æ–≤–æ.")
        except Exception as e:
            self._print(f"[dump] –û—à–∏–±–∫–∞: {e}")

    # ----------------- –æ–±—ä–µ–¥–∏–Ω—ë–Ω–Ω—ã–π –¥–∞–º–ø –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤ –≤ –æ–¥–∏–Ω -----------------
    def _dump_code_all(self, out_filename: str = None) -> str:
        """
        –°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ .py —Ñ–∞–π–ª—ã –ø—Ä–æ–µ–∫—Ç–∞ –≤ –æ–¥–∏–Ω —Ñ–∞–π–ª.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–º—É —Ñ–∞–π–ª—É.
        """
        root_dir = os.path.dirname(os.path.dirname(__file__))
        dumps_dir = os.path.join(root_dir, "dcli_dumps")
        os.makedirs(dumps_dir, exist_ok=True)

        if out_filename:
            safe_name = out_filename
        else:
            ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_name = f"all_code_{ts}.txt"

        out_path = os.path.join(dumps_dir, safe_name)

        with open(out_path, "w", encoding="utf-8") as out_f:
            header = (
                f"All project .py files dump\nGenerated: {datetime.datetime.now().isoformat()}\n"
                f"Project root: {root_dir}\n\n"
            )
            out_f.write(header)
            for dirpath, _, files in os.walk(root_dir):
                # –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ –∏ —Å–∏—Å—Ç–µ–º–Ω—ã–µ –∫–∞—Ç–∞–ª–æ–≥–∏
                base = os.path.basename(dirpath)
                if base.startswith("__pycache__") or base.startswith("."):
                    continue
                rel_dir = os.path.relpath(dirpath, root_dir)
                for fname in sorted(files):
                    if not fname.endswith(".py"):
                        continue
                    file_path = os.path.join(dirpath, fname)
                    rel_path = os.path.join(rel_dir, fname) if rel_dir != "." else fname
                    out_f.write(f"\n--- FILE: {rel_path} ---\n")
                    try:
                        with open(file_path, "r", encoding="utf-8") as fh:
                            out_f.write(fh.read() + "\n")
                    except Exception as e:
                        out_f.write(f"[ERROR reading file: {e}]\n")

        return out_path


--- FILE: ui\main_ui.py ---
# ui/main_ui.py
import tkinter as tk
from tkinter import ttk

from services.db import Database
from services.notes_service import NotesService
from .notes_ui import NotesUI
from .dev_cli import DevCLI


class RacconApp:
    """
    –ì–ª–∞–≤–Ω–æ–µ –æ–∫–Ω–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.
    –ë–∞–∑–æ–≤—ã–π –º–∏–Ω–∏–º—É–º: –≤–∫–ª–∞–¥–∫–∞ '–ó–∞–º–µ—Ç–∫–∏' + –∫–Ω–æ–ø–∫–∞ DCLI –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏.
    """

    def __init__(self, db_path: str = "raccon.db"):
        # –ö–æ—Ä–Ω–µ–≤–æ–µ –æ–∫–Ω–æ
        self.root = tk.Tk()
        self.root.title("Raccon Pro")
        self.root.geometry("900x600")

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤
        self.db = Database(db_path)
        self.notes_service = NotesService(self.db)

        # –û—Å–Ω–æ–≤–Ω–æ–π Notebook
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill="both", expand=True)

        # –í–∫–ª–∞–¥–∫–∞: –ó–∞–º–µ—Ç–∫–∏
        self.notes_tab = NotesUI(self.notebook, self.notes_service)
        self.notebook.add(self.notes_tab.frame, text="–ó–∞–º–µ—Ç–∫–∏")

        # –ó–∞–≥–ª—É—à–∫–∏ –ø–æ–¥ –±—É–¥—É—â–∏–µ –º–æ–¥—É–ª–∏
        self.tasks_tab = ttk.Frame(self.notebook)
        self.passwords_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.tasks_tab, text="–ó–∞–¥–∞—á–∏")
        self.notebook.add(self.passwords_tab, text="–ü–∞—Ä–æ–ª–∏")

        # –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å —Å –∫–Ω–æ–ø–∫–æ–π DCLI
        bottom_frame = ttk.Frame(self.root)
        bottom_frame.pack(fill="x", side="bottom", pady=4)

        dcli_btn = ttk.Button(bottom_frame, text="DCLI", command=self.open_cli)
        dcli_btn.pack(side="left", padx=6)

    def open_cli(self):
        # –û—Ç–∫—Ä—ã–≤–∞–µ–º DevCLI –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –æ–∫–Ω–µ
        DevCLI(self.root, db=self.db, notes_service=self.notes_service)

    def run(self):
        self.root.mainloop()


--- FILE: ui\notes_ui.py ---
import tkinter as tk
from tkinter import ttk, messagebox


class NotesUI:
    def __init__(self, master, notes_service):
        self.master = master
        self.notes_service = notes_service

        self.frame = ttk.Frame(master)

        # –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å
        control = ttk.Frame(self.frame)
        control.pack(fill="x", padx=6, pady=6)

        ttk.Label(control, text="–ó–∞–≥–æ–ª–æ–≤–æ–∫:").pack(side="left")
        self.title_entry = ttk.Entry(control, width=30)
        self.title_entry.pack(side="left", padx=6)

        ttk.Label(control, text="–¢–µ–≥–∏:").pack(side="left")
        self.tags_entry = ttk.Entry(control, width=20)
        self.tags_entry.pack(side="left", padx=6)

        ttk.Button(control, text="–î–æ–±–∞–≤–∏—Ç—å", command=self.add_note).pack(side="left", padx=6)

        ttk.Label(control, text="–ü–æ–∏—Å–∫:").pack(side="left", padx=(20, 0))
        self.search_entry = ttk.Entry(control, width=25)
        self.search_entry.pack(side="left", padx=6)

        ttk.Button(control, text="–ò—Å–∫–∞—Ç—å", command=self.search_notes).pack(side="left", padx=6)
        ttk.Button(control, text="–°–±—Ä–æ—Å", command=self.load_notes).pack(side="left", padx=6)

        # –¢–∞–±–ª–∏—Ü–∞
        self.tree = ttk.Treeview(
            self.frame,
            columns=("id", "title", "tags", "created_at"),
            show="headings",
            height=15
        )
        self.tree.pack(fill="both", expand=True, padx=6, pady=6)

        self.tree.heading("id", text="ID")
        self.tree.heading("title", text="–ó–∞–≥–æ–ª–æ–≤–æ–∫")
        self.tree.heading("tags", text="–¢–µ–≥–∏")
        self.tree.heading("created_at", text="–°–æ–∑–¥–∞–Ω–æ")

        self.tree.column("id", width=60, anchor="center")
        self.tree.column("title", width=320, anchor="w")
        self.tree.column("tags", width=160, anchor="w")
        self.tree.column("created_at", width=160, anchor="center")

        # –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å
        bottom = ttk.Frame(self.frame)
        bottom.pack(fill="x", padx=6, pady=6)

        ttk.Button(bottom, text="–£–¥–∞–ª–∏—Ç—å", command=self.delete_note).pack(side="left")
        ttk.Button(bottom, text="–ü—Ä–æ—Å–º–æ—Ç—Ä", command=self.view_note).pack(side="left", padx=6)
        ttk.Button(bottom, text="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", command=self.edit_note).pack(side="left", padx=6)

        self.load_notes()

    # CRUD –∏ –ø–æ–∏—Å–∫
    def load_notes(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        try:
            rows = self.notes_service.get_all_notes()
            if rows:
                for note in rows:
                    self.tree.insert("", "end", values=note)
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∑–∞–º–µ—Ç–∫–∏: {e}")

    def add_note(self):
        title = self.title_entry.get().strip()
        tags = self.tags_entry.get().strip()
        if not title:
            messagebox.showwarning("–û—à–∏–±–∫–∞", "–ó–∞–≥–æ–ª–æ–≤–æ–∫ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
            return
        try:
            self.notes_service.create_note(title, "", tags)
            self.title_entry.delete(0, "end")
            self.tags_entry.delete(0, "end")
            self.load_notes()
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", str(e))

    def search_notes(self):
        q = self.search_entry.get().strip()
        if not q:
            self.load_notes()
            return
        try:
            results = self.notes_service.search_notes(q)
            for row in self.tree.get_children():
                self.tree.delete(row)
            for note in results:
                self.tree.insert("", "end", values=note)
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", str(e))

    def delete_note(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("–û—à–∏–±–∫–∞", "–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–º–µ—Ç–∫—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è")
            return
        note_id = self.tree.item(sel[0])["values"][0]
        try:
            self.notes_service.delete_note(note_id)
            self.load_notes()
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", str(e))

    def view_note(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("–û—à–∏–±–∫–∞", "–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–º–µ—Ç–∫—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞")
            return
        note_id = self.tree.item(sel[0])["values"][0]
        try:
            note = self.notes_service.get_note_by_id(note_id)
            if note:
                _, title, content, tags, created_at = note
                messagebox.showinfo(
                    "–ó–∞–º–µ—Ç–∫–∞",
                    f"–ó–∞–≥–æ–ª–æ–≤–æ–∫: {title}\n–¢–µ–≥–∏: {tags}\n–°–æ–∑–¥–∞–Ω–æ: {created_at}\n\n{content}"
                )
        except Exception as e:
            messagebox.showerror("–û—à–∏–±–∫–∞", str(e))

    def edit_note(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("–û—à–∏–±–∫–∞", "–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–º–µ—Ç–∫—É –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è")
            return
        note_id = self.tree.item(sel[0])["values"][0]
        note = self.notes_service.get_note_by_id(note_id)
        if not note:
            return

        _, old_title, old_content, old_tags, _ = note

        win = tk.Toplevel(self.frame)
        win.title("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∑–∞–º–µ—Ç–∫—É")
        win.geometry("480x380")

        tk.Label(win, text="–ó–∞–≥–æ–ª–æ–≤–æ–∫:").pack(anchor="w", padx=8, pady=(8, 0))
        title_entry = tk.Entry(win, width=60)
        title_entry.insert(0, old_title)
        title_entry.pack(padx=8, pady=4)

        tk.Label(win, text="–¢–µ–≥–∏:").pack(anchor="w", padx=8, pady=(8, 0))
        tags_entry = tk.Entry(win, width=60)
        tags_entry.insert(0, old_tags)
        tags_entry.pack(padx=8, pady=4)

        tk.Label(win, text="–°–æ–¥–µ—Ä–∂–∏–º–æ–µ:").pack(anchor="w", padx=8, pady=(8, 0))
        content_text = tk.Text(win, width=60, height=12)
        content_text.insert("1.0", old_content)
        content_text.pack(padx=8, pady=4)

        def save_changes():
            new_title = title_entry.get().strip()
            new_tags = tags_entry.get().strip()
            new_content = content_text.get("1.0", "end").strip()
            if not new_title:
                messagebox.showwarning("–û—à–∏–±–∫–∞", "–ó–∞–≥–æ–ª–æ–≤–æ–∫ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
                return
            try:
                self.notes_service.update_note(note_id, new_title, new_content, new_tags)
                self.load_notes()
                win.destroy()
            except Exception as e:
                messagebox.showerror("–û—à–∏–±–∫–∞", str(e))

        tk.Button(win, text="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", command=save_changes).pack(pady=10)

