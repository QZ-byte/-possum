
===== [dev_cli.py] =====
# dev_cli.py
import tkinter as tk
from tkinter import ttk, messagebox
import os
from code_tools import save_code_snapshot

class DevCLI(tk.Toplevel):
    def __init__(self, master=None, db=None, notes_service=None):
        super().__init__(master)
        self.title("Developer CLI")
        self.geometry("420x320")
        self.resizable(False, False)
        self.db = db
        self.notes_service = notes_service

        ttk.Label(self, text="Выберите опцию:", font=("Arial", 12, "bold")).pack(pady=10)

        options = [
            ("Dump Code Snapshot", self.run_dump),
            ("Показать информацию о проекте", self.show_info),
            ("Очистить базу данных", self.clear_db),
            ("Экспорт заметок в Markdown", self.export_notes_md),
            ("Закрыть CLI", self.close_cli),
        ]

        for text, cmd in options:
            ttk.Button(self, text=text, command=cmd).pack(fill="x", padx=20, pady=6)

    def run_dump(self):
        try:
            save_code_snapshot()
            messagebox.showinfo("Готово", "Снимок кода сохранён в code_snapshot.txt")
        except Exception as e:
            messagebox.showerror("Ошибка", str(e))
        finally:
            self.destroy()

    def show_info(self):
        try:
            cwd = os.getcwd()
            db_path = getattr(self.db, "path", "—")
            note_count = 0
            if self.notes_service:
                rows = self.notes_service.get_all_notes()
                note_count = len(rows) if rows else 0
            info = f"Текущая папка: {cwd}\nDB: {db_path}\nЗаметок: {note_count}"
            messagebox.showinfo("Инфо", info)
        except Exception as e:
            messagebox.showerror("Ошибка", str(e))
        finally:
            self.destroy()

    def clear_db(self):
        try:
            path = getattr(self.db, "path", None)
            if path and os.path.exists(path):
                self.db.close()
                os.remove(path)
                messagebox.showinfo("OK", "Файл БД удалён")
            else:
                messagebox.showwarning("Нет файла", "Файл базы данных не найден")
        except Exception as e:
            messagebox.showerror("Ошибка", str(e))
        finally:
            self.destroy()

    def export_notes_md(self):
        try:
            if not self.notes_service:
                raise RuntimeError("NotesService не передан")
            notes = self.notes_service.get_all_notes_full()
            out_lines = []
            for n in notes:
                nid, title, content, tags, created_at = n
                out_lines.append(f"# {title}\n\n_Теги: {tags} | Создано: {created_at}_\n\n{content}\n\n---\n")
            out_path = os.path.join(os.getcwd(), "notes_export.md")
            with open(out_path, "w", encoding="utf-8") as f:
                f.write("\n".join(out_lines))
            messagebox.showinfo("Экспорт", f"Заметки экспортированы в {out_path}")
        except Exception as e:
            messagebox.showerror("Ошибка", str(e))
        finally:
            self.destroy()

    def close_cli(self):
        self.destroy()


===== [main.py] =====
# main.py
from ui import RacconApp

def main():
    app = RacconApp()
    app.run()

if __name__ == "__main__":
    main()


===== [notes_ui.py] =====
# notes_ui.py
import tkinter as tk
from tkinter import ttk, messagebox


class NotesUI:
    def __init__(self, master, notes_service):
        self.master = master
        self.notes_service = notes_service

        self.frame = ttk.Frame(master)

        # Верхняя панель управления
        control_frame = ttk.Frame(self.frame)
        control_frame.pack(fill="x", padx=5, pady=5)

        ttk.Label(control_frame, text="Заголовок:").pack(side="left")
        self.title_entry = ttk.Entry(control_frame, width=30)
        self.title_entry.pack(side="left", padx=5)

        ttk.Label(control_frame, text="Теги:").pack(side="left")
        self.tags_entry = ttk.Entry(control_frame, width=20)
        self.tags_entry.pack(side="left", padx=5)

        add_btn = ttk.Button(control_frame, text="Добавить", command=self.add_note)
        add_btn.pack(side="left", padx=5)

        ttk.Label(control_frame, text="Поиск:").pack(side="left", padx=(20, 0))
        self.search_entry = ttk.Entry(control_frame, width=25)
        self.search_entry.pack(side="left", padx=5)

        search_btn = ttk.Button(control_frame, text="Искать", command=self.search_notes)
        search_btn.pack(side="left", padx=5)

        reset_btn = ttk.Button(control_frame, text="Сброс", command=self.load_notes)
        reset_btn.pack(side="left", padx=5)

        # Таблица заметок
        self.tree = ttk.Treeview(
            self.frame,
            columns=("id", "title", "tags", "created_at"),
            show="headings",
            height=15
        )
        self.tree.pack(fill="both", expand=True, padx=5, pady=5)

        self.tree.heading("id", text="ID")
        self.tree.heading("title", text="Заголовок")
        self.tree.heading("tags", text="Теги")
        self.tree.heading("created_at", text="Создано")

        self.tree.column("id", width=50, anchor="center")
        self.tree.column("title", width=300)
        self.tree.column("tags", width=150)
        self.tree.column("created_at", width=160)

        # Нижняя панель
        bottom_frame = ttk.Frame(self.frame)
        bottom_frame.pack(fill="x", padx=5, pady=5)

        delete_btn = ttk.Button(bottom_frame, text="Удалить", command=self.delete_note)
        delete_btn.pack(side="left")

        view_btn = ttk.Button(bottom_frame, text="Просмотр", command=self.view_note)
        view_btn.pack(side="left", padx=5)

        edit_btn = ttk.Button(bottom_frame, text="Редактировать", command=self.edit_note)
        edit_btn.pack(side="left", padx=5)

        self.load_notes()

    # === Методы работы с заметками ===
    def load_notes(self):
        for row in self.tree.get_children():
            self.tree.delete(row)
        rows = self.notes_service.get_all_notes()
        if rows:
            for note in rows:
                self.tree.insert("", "end", values=note)

    def add_note(self):
        title = self.title_entry.get().strip()
        tags = self.tags_entry.get().strip()
        if not title:
            messagebox.showwarning("Ошибка", "Заголовок не может быть пустым")
            return
        try:
            self.notes_service.create_note(title, "", tags)
            self.title_entry.delete(0, "end")
            self.tags_entry.delete(0, "end")
            self.load_notes()
        except Exception as e:
            messagebox.showerror("Ошибка", str(e))

    def search_notes(self):
        query = self.search_entry.get().strip()
        if not query:
            self.load_notes()
            return
        try:
            results = self.notes_service.search_notes(query)
            for row in self.tree.get_children():
                self.tree.delete(row)
            for note in results:
                self.tree.insert("", "end", values=note)
        except Exception as e:
            messagebox.showerror("Ошибка", str(e))

    def delete_note(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("Ошибка", "Выберите заметку для удаления")
            return
        note_id = self.tree.item(selected[0])["values"][0]
        try:
            self.notes_service.delete_note(note_id)
            self.load_notes()
        except Exception as e:
            messagebox.showerror("Ошибка", str(e))

    def view_note(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("Ошибка", "Выберите заметку для просмотра")
            return
        note_id = self.tree.item(selected[0])["values"][0]
        note = self.notes_service.get_note_by_id(note_id)
        if note:
            _, title, content, tags, created_at = note
            messagebox.showinfo(
                "Заметка",
                f"Заголовок: {title}\nТеги: {tags}\nСоздано: {created_at}\n\n{content}"
            )

    def edit_note(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showwarning("Ошибка", "Выберите заметку для редактирования")
            return
        note_id = self.tree.item(selected[0])["values"][0]
        note = self.notes_service.get_note_by_id(note_id)
        if not note:
            return

        _, old_title, old_content, old_tags, _ = note

        edit_win = tk.Toplevel(self.frame)
        edit_win.title("Редактировать заметку")
        edit_win.geometry("480x380")

        tk.Label(edit_win, text="Заголовок:").pack(anchor="w", padx=8, pady=(8, 0))
        title_entry = tk.Entry(edit_win, width=60)
        title_entry.insert(0, old_title)
        title_entry.pack(padx=8, pady=4)

        tk.Label(edit_win, text="Теги:").pack(anchor="w", padx=8, pady=(8, 0))
        tags_entry = tk.Entry(edit_win, width=60)
        tags_entry.insert(0, old_tags)
        tags_entry.pack(padx=8, pady=4)

        tk.Label(edit_win, text="Содержимое:").pack(anchor="w", padx=8, pady=(8, 0))
        content_text = tk.Text(edit_win, width=60, height=12)
        content_text.insert("1.0", old_content)
        content_text.pack(padx=8, pady=4)

        def save_changes():
            new_title = title_entry.get().strip()
            new_tags = tags_entry.get().strip()
            new_content = content_text.get("1.0", "end").strip()
            if not new_title:
                messagebox.showwarning("Ошибка", "Заголовок не может быть пустым")
                return
            try:
                self.notes_service.update_note(note_id, new_title, new_content, new_tags)
                self.load_notes()
                edit_win.destroy()
            except Exception as e:
                messagebox.showerror("Ошибка", str(e))

        tk.Button(edit_win, text="Сохранить", command=save_changes).pack(pady=10)


===== [ui.py] =====
# ui.py
import tkinter as tk
from tkinter import ttk

from services.db import Database
from services.notes_service import NotesService
from notes_ui import NotesUI
from dev_cli import DevCLI


class RacconApp:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Raccon Pre α")
        self.root.geometry("900x600")

        # --- сервисы ---
        self.db = Database("raccon.db")
        self.notes_service = NotesService(self.db)

        # --- вкладки ---
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill="both", expand=True)

        # Заметки
        self.notes_tab = NotesUI(self.notebook, self.notes_service)
        self.notebook.add(self.notes_tab.frame, text="Заметки")

        # Заглушки для будущих модулей
        self.tasks_tab = ttk.Frame(self.notebook)
        self.passwords_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.tasks_tab, text="Задачи")
        self.notebook.add(self.passwords_tab, text="Пароли")

        # --- нижняя панель с кнопками ---
        bottom_frame = ttk.Frame(self.root)
        bottom_frame.pack(fill="x", side="bottom", pady=4)

        dev_btn = ttk.Button(bottom_frame, text="Dev CLI", command=self.open_cli)
        dev_btn.pack(side="right", padx=6)

    def open_cli(self):
        DevCLI(self.root, db=self.db, notes_service=self.notes_service)

    def run(self):
        self.root.mainloop()


===== [services\db.py] =====
# services/db.py
import sqlite3
from typing import List, Tuple, Any, Optional

class Database:
    def __init__(self, path: str = "raccon.db"):
        self.path = path
        self.conn = sqlite3.connect(self.path, check_same_thread=False)
        self.conn.row_factory = sqlite3.Row
        self._ensure_pragmas()

    def _ensure_pragmas(self):
        try:
            cur = self.conn.cursor()
            cur.execute("PRAGMA foreign_keys = ON;")
            cur.close()
        except Exception:
            pass

    def execute(self, query: str, params: Tuple = ()):
        cur = self.conn.cursor()
        cur.execute(query, params)
        self.conn.commit()
        cur.close()

    def fetchall(self, query: str, params: Tuple = ()):
        cur = self.conn.cursor()
        cur.execute(query, params)
        rows = cur.fetchall()
        cur.close()
        return [tuple(r) for r in rows]

    def fetchone(self, query: str, params: Tuple = ()):
        cur = self.conn.cursor()
        cur.execute(query, params)
        row = cur.fetchone()
        cur.close()
        return tuple(row) if row else None

    def close(self):
        try:
            self.conn.close()
        except Exception:
            pass


===== [services\init.py] =====


===== [services\notes_service.py] =====
# services/notes_service.py
import datetime
from services.db import Database

class NotesService:
    def __init__(self, db: Database):
        self.db = db
        self._init_table()

    def _init_table(self):
        query = """
        CREATE TABLE IF NOT EXISTS notes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL,
            content TEXT,
            tags TEXT,
            created_at TEXT NOT NULL
        )
        """
        self.db.execute(query)

    def create_note(self, title: str, content: str = "", tags: str = ""):
        query = """
        INSERT INTO notes (title, content, tags, created_at)
        VALUES (?, ?, ?, ?)
        """
        created_at = datetime.datetime.now().isoformat(sep=" ", timespec="seconds")
        self.db.execute(query, (title, content, tags, created_at))

    def get_all_notes(self):
        query = "SELECT id, title, tags, created_at FROM notes ORDER BY id DESC"
        return self.db.fetchall(query)

    def get_all_notes_full(self):
        query = "SELECT id, title, content, tags, created_at FROM notes ORDER BY id DESC"
        return self.db.fetchall(query)

    def get_note_by_id(self, note_id: int):
        query = "SELECT * FROM notes WHERE id = ?"
        return self.db.fetchone(query, (note_id,))

    def search_notes(self, keyword: str):
        query = """
        SELECT id, title, tags, created_at
        FROM notes
        WHERE title LIKE ? OR tags LIKE ?
        ORDER BY id DESC
        """
        like = f"%{keyword}%"
        return self.db.fetchall(query, (like, like))

    def update_note(self, note_id: int, title: str, content: str, tags: str):
        query = """
        UPDATE notes
        SET title = ?, content = ?, tags = ?
        WHERE id = ?
        """
        self.db.execute(query, (title, content, tags, note_id))

    def delete_note(self, note_id: int):
        query = "DELETE FROM notes WHERE id = ?"
        self.db.execute(query, (note_id,))

